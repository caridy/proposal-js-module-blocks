<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<pre class="metadata">
title: JavaScript Module Blocks
stage: 2
contributors: Surma, Dan Ehrenberg, Caridy Patiño
</pre>

<emu-clause id="sec-primary-expression">
  <h1>Primary Expression</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    PrimaryExpression[Yield, Await] :
      IdentifierReference[?Yield, ?Await]
      Literal
      ArrayLiteral[?Yield, ?Await]
      ObjectLiteral[?Yield, ?Await]
      FunctionExpression
      ClassExpression[?Yield, ?Await]
      GeneratorExpression
      AsyncFunctionExpression
      AsyncGeneratorExpression
      <ins>ModuleBlockExpression</ins>
      RegularExpressionLiteral
      TemplateLiteral[?Yield, ?Await, ~Tagged]
      CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover
  </emu-grammar>
</emu-clause>

<emu-clause id="sec-module-block-definitions">
  <h1>Module Block Definitions</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    ModuleBlockExpression :
      `module` [no LineTerminator here] `{` ModuleBody? `}`
  </emu-grammar>

  <emu-clause id="sec-module-block-definitions-runtime-semantics-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>
    <emu-grammar>PrimaryExpression : ModuleBlockExpression</emu-grammar>
    <emu-alg>
      1. Let _referencingScriptOrModule_ be GetActiveScriptOrModule().
      1. Let _moduleSource_ be ? OrdinaryObjectCreate(*"%ModuleSource.prototype%"*, « [[ModuleSource]] »).
      1. Set _moduleSource_.[[ModuleSource]] to ? ParseModuleSource(_body_).
      1. Let _O_ be ? OrdinaryObjectCreate(*"%Module.prototype%"*, « [[Module]], [[ModuleSourceInstance]], [[ImportHook]] »).
      1. Let _moduleRecord_ to ! CreateModuleRecord(_moduleSource_.[[ModuleSource]]).
      1. Set _moduleRecord_.[[ModuleInstance]] to _O_.
      1. Let _importHookClosure_ be a new Abstract Closure with parameters (_specifier_) that captures _referencingScriptOrModule_ and performs the following steps when called
        1. Assert: Type(_specifier_) is String.
        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
        1. Perform HostImportModuleDynamically(_referencingScriptOrModule_, _specifier_, _promiseCapability_).
        1. Return _promiseCapability_.[[Promise]].
      1. Set _O_.[[Module]] to _moduleRecord_.
      1. Set _O_.[[ModuleSourceInstance]] to _moduleSource_.
      1. Set _O_.[[ImportHook]] be CreateBuiltinFunction(_importHookClosure_, 1, *""*, &laquo; &raquo;).
      1. Perform HostInitializeModuleBlock(_moduleRecord_, _referencingScriptOrModule_).
      1. Return _O_.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-moduleblocks-abstract-operations">
  <h1>Module Block Abstract Operations</h1>
  <emu-clause id="sec-hostinitializemoduleblock" type="host-defined abstract operation">
    <h1>
      HostInitializeModuleBlock (
        _moduleRecord_: a Module Record,
        _referencingScriptOrModule_: a Script Record, a Module Record, or *null*
      ): ~unused~
    </h1>
    <dl class="header">
      <dt>description</dt>
      <dd>Initializes a Module Record corresponding to a Module Block with host-dependent information.</dd>
    </dl>
  </emu-clause>
  <emu-note type="editor">
    The host can make the arrangements to support import.meta and probably to add [[HostDefined]] field on the Module Record. If _referencingScriptOrModule_ is a Module Record, it could be a Module Record associated to another Module Instance, in which case [[ImportMeta]] field can be copied from it.
  </emu-note>
</emu-clause>

<emu-clause id="sec-modulesource-objects">
  <h1>ModuleSource Objects</h1>
  <emu-clause id="sec-modulesource-abstracts">
    <h1>ModuleSource Abstract Operations</h1>
    <emu-clause id="sec-parsemodulesource" type="abstract operation">
      <h1>
        ParseModuleSource (
          _sourceText_: ECMAScript source text<ins> or a |Module| Parse Node</ins>,
        ): a Module Source Record or throw a *SyntaxError* object
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Module Source Record based upon <ins></ins>the provided Parse Node, or</ins> the result of parsing _sourceText_ as a |Module|.</dd>
      </dl>
      <emu-alg>
        1. <ins>If _sourceText_ is a Parse Node,</ins>
          1. <ins>Let _body_ be _sourceText_.</ins>
        1. <ins>Else,</ins>
          1. Let _body_ be ParseText(_sourceText_, |Module|).
        1. If _body_ is a List of errors, throw a *SyntaxError* exception.
        1. Let _requestedModules_ be the ModuleRequests of _body_.
        1. Let _importEntries_ be ImportEntries of _body_.
        1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).
        1. Let _indirectExportEntries_ be a new empty List.
        1. Let _localExportEntries_ be a new empty List.
        1. Let _starExportEntries_ be a new empty List.
        1. Let _exportEntries_ be ExportEntries of _body_.
        1. For each ExportEntry Record _ee_ of _exportEntries_, do
          1. If _ee_.[[ModuleRequest]] is *null*, then
            1. If _ee_.[[LocalName]] is not an element of _importedBoundNames_, then
              1. Append _ee_ to _localExportEntries_.
            1. Else,
              1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is the same as _ee_.[[LocalName]].
              1. If _ie_.[[ImportName]] is ~namespace-object~, then
                1. NOTE: This is a re-export of an imported module namespace object.
                1. Append _ee_ to _localExportEntries_.
              1. Else,
                1. NOTE: This is a re-export of a single name.
                1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.
          1. Else if _ee_.[[ImportName]] is ~all-but-default~, then
            1. Assert: _ee_.[[ExportName]] is *null*.
            1. Append _ee_ to _starExportEntries_.
          1. Else,
            1. Append _ee_ to _indirectExportEntries_.
        1. Let _async_ be _body_ Contains `await`.
        1. NOTE: How should _hostDefined_ be populated if this operation is triggered by the user and whether or not _hostDefined_ should be used for sources created in user land.
        1. Let _hostDefined_ be *undefined*.
        1. Return Module Source Record { [[HasTLA]]: _async_, [[ECMAScriptCode]]: _body_, [[RequestedModules]]: _requestedModules_, [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[HostDefined]]: _hostDefined_ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
