<pre class="metadata">
title: JavaScript Module Blocks
stage: 2
contributors: Surma, Dan Ehrenberg
</pre>

<emu-clause id="sec-primary-expression">
  <h1>Primary Expression</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    PrimaryExpression[Yield, Await] :
      IdentifierReference[?Yield, ?Await]
      Literal
      ArrayLiteral[?Yield, ?Await]
      ObjectLiteral[?Yield, ?Await]
      FunctionExpression
      ClassExpression[?Yield, ?Await]
      GeneratorExpression
      AsyncFunctionExpression
      AsyncGeneratorExpression
      <ins>ModuleBlockExpression</ins>
      <ins>ModuleFunctionExpression</ins>
      <ins>ModuleGeneratorExpression</ins>
      <ins>ModuleAsyncFunctionExpression</ins>
      <ins>ModuleAsyncGeneratorExpression</ins>
      RegularExpressionLiteral
      TemplateLiteral[?Yield, ?Await, ~Tagged]
      CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover
  </emu-grammar>
</emu-clause>

<emu-clause id="sec-module-block-definitions">
  <h1>Module Block Definitions</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    ModuleBlockExpression :
      `module` [no LineTerminator here] `{` ModuleBody? `}`
    ModuleFunctionExpression :
      `module` [no LineTerminator here] FunctionExpression
    ModuleGeneratorExpression :
      `module` [no LineTerminator here] GeneratorExpression
    ModuleAsyncFunctionExpression :
      `module` [no LineTerminator here] AsyncFunctionExpression
    ModuleAsyncGeneratorExpression :
      `module` [no LineTerminator here] AsyncGeneratorExpression
  </emu-grammar>

  <h2>Runtime Semantics: Evaluation</h2>
  <emu-grammar>PrimaryExpression : ModuleBlockExpression</emu-grammar>
  <emu-alg>
    1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%,  &laquo; [[HostDefined]], [[ModuleBlockBody]], [[SourceText]] &raquo;).
    1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleBlockExpression|.
    1. Let _parsedBody_ be ? ParseText(_body_, Module).
    1. Set _moduleBlock_.[[ModuleBlockBody]] to _parsedBody_.
    1. Perform ! HostInitializeModuleBlock(_moduleBlock_).
    1. Return _moduleBlock_.
  </emu-alg>

  <emu-grammar>PrimaryExpression : ModuleFunctionExpression</emu-grammar>
  <emu-alg>
    1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%,  &laquo; [[HostDefined]], [[ModuleBlockBody]], [[SourceText]] &raquo;).
    1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleFunctionExpression|.
    1. let _moduleFunctionSource_ be the source text matched by |FunctionExpression|.
    1. Let _parsedBody_ be ? ParseText("export default " + _moduleFunctionSource_, Module).
    1. Set _moduleBlock_.[[ModuleBlockBody]] to _parsedBody_.
    1. Perform ! HostInitializeModuleBlock(_moduleBlock_).
    1. Return _moduleBlock_.
  </emu-alg>

  <emu-grammar>PrimaryExpression : ModuleGeneratorExpression</emu-grammar>
  <emu-alg>
    1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%,  &laquo; [[HostDefined]], [[ModuleBlockBody]], [[SourceText]] &raquo;).
    1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleGeneratorExpression|.
    1. let _moduleFunctionSource_ be the source text matched by |GeneratorExpression|.
    1. Let _parsedBody_ be ? ParseText("export default " + _moduleFunctionSource_, Module).
    1. Set _moduleBlock_.[[ModuleBlockBody]] to _parsedBody_.
    1. Perform ! HostInitializeModuleBlock(_moduleBlock_).
    1. Return _moduleBlock_.
  </emu-alg>

  <emu-grammar>PrimaryExpression : ModuleAsyncFunctionExpression</emu-grammar>
  <emu-alg>
    1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%,  &laquo; [[HostDefined]], [[ModuleBlockBody]], [[SourceText]] &raquo;).
    1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleAsyncFunctionExpression|.
    1. let _moduleFunctionSource_ be the source text matched by |AsyncFunctionExpression|.
    1. Let _parsedBody_ be ? ParseText("export default " + _moduleFunctionSource_, Module).
    1. Set _moduleBlock_.[[ModuleBlockBody]] to _parsedBody_.
    1. Perform ! HostInitializeModuleBlock(_moduleBlock_).
    1. Return _moduleBlock_.
  </emu-alg>
  
  <emu-grammar>PrimaryExpression : ModuleAsyncGeneratorExpression</emu-grammar>
  <emu-alg>
    1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%,  &laquo; [[HostDefined]], [[ModuleBlockBody]], [[SourceText]] &raquo;).
    1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleAsyncGeneratorExpression|.
    1. let _moduleFunctionSource_ be the source text matched by |AsyncGeneratorExpression|.
    1. Let _parsedBody_ be ? ParseText("export default " + _moduleFunctionSource_, Module).
    1. Set _moduleBlock_.[[ModuleBlockBody]] to _parsedBody_.
    1. Perform ! HostInitializeModuleBlock(_moduleBlock_).
    1. Return _moduleBlock_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-moduleblock">
  <h1>ModuleBlock ( _body_ )</h1>
  <emu-alg>
    1. Throw a *TypeError* exception.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-moduleblock.prototype">
  <h1>ModuleBlock.prototype</h1>
  <p>The initial value of `ModuleBlock.prototype` is the ModuleBlock prototype object.</p>
  <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
</emu-clause>

<emu-clause id="sec-properties-of-the-moduleblock-prototype-object">
  <h1>Properties of the ModuleBlock Prototype Object</h1>
  <p>The <dfn>ModuleBlock prototype object</dfn>:</p>
  <ul>
    <li>is <dfn>%ModuleBlock.prototype%</dfn>.</li>
    <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    <li>is an ordinary object.</li>
  </ul>

  <emu-clause id="sec-moduleblock.prototype.tostring">
    <h1>ModuleBlock.prototype.toString ( )</h1>
    <p>The following steps are taken:</p>
    <emu-alg>
      1. Let _module_ be the *this* value.
      1. If Type(_module_) is Object and has the internal slot [[ModuleBlockBody]]
        1. Return _module_.[[SourceText]].
      1. Throw a *TypeError* exception.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-import-calls">
  <h1>Import Calls</h1>

  <emu-clause id="sec-import-call-runtime-semantics-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>

    <emu-grammar>ImportCall : `import` `(` AssignmentExpression `)`</emu-grammar>
    <emu-alg>
      1. Let _referencingScriptOrModule_ be ! GetActiveScriptOrModule().
      1. Let _argRef_ be the result of evaluating |AssignmentExpression|.
      1. Let _specifier_ be ? GetValue(_argRef_).
      1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
      1. <del>Let _specifierString_ be ToString(_specifier_).</del>
      1. <ins>If Type(_specifier_) is not Object or _specifier_ does not have the internal slot [[ModuleBlockBody]]</ins>
        1. <ins>Set _specifier_ to ToString(_specifier_).</ins>
        1. IfAbruptRejectPromise(<del>_specifierString_</del><ins>_specifier_</ins>, _promiseCapability_).
      1. Perform ! <del>HostImportModuleDynamically</del><ins>ImportModuleDynamically</ins>(_referencingScriptOrModule_, <del>_specifierString_</del><ins>_specifier_</ins>, _promiseCapability_).
      1. Return _promiseCapability_.[[Promise]].
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-hostinitializemoduleblock" type="host-defined abstract operation">
  <h1>
    HostInitializeModuleBlock (
      _moduleBlock_: a Module Block,
    )
  </h1>
  <dl class="header">
    <dt>description</dt>
    <dd>Initializes a Module Block with host-dependent information.</dd>
  </dl>
</emu-clause>


<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>Executable Code and Execution Contexts</h1>

  <emu-clause id="sec-code-realms">
    <h1>Realms</h1>
    <p>Before it is evaluated, all ECMAScript code must be associated with a <dfn id="realm" variants="realms">realm</dfn>. Conceptually, a realm consists of a set of intrinsic objects, an ECMAScript global environment, all of the ECMAScript code that is loaded within the scope of that global environment, and other associated state and resources.</p>
    <p>A realm is represented in this specification as a <dfn id="realm-record" variants="Realm Records">Realm Record</dfn> with the fields specified in <emu-xref href="#table-realm-record-fields"></emu-xref>:</p>
    <emu-table id="table-realm-record-fields" caption="Realm Record Fields" oldids="table-21">
      <table>
        <tr>
          <th>
            Field Name
          </th>
          <th>
            Value
          </th>
          <th>
            Meaning
          </th>
        </tr>
        <tr>
          <td>
            [[Intrinsics]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            [[GlobalObject]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            [[GlobalEnv]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            [[TemplateMap]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            <ins>[[ModuleMap]]</ins>
          </td>
          <td>
            <ins>a List of Record { [[ReferencingScriptOrModule]]: Script Record or Module Record or *null*, [[Specifier]]: String, [[ModuleRecord]]: Module Record }</ins>
          </td>
          <td>
            <p><ins>Module Records are cached separately per Realm: two imports from the same realm using the same specifier from the same referencing script or module must resolve to the same Module Record. The cache needs to be per-Realm to support cases when [[ReferencingScriptOrModule]] is *null*.</ins></p>
            <p><ins>This List respects the following invariant:</ins></p>
            <ul>
              <li>
                <ins>It does not contain two Records _record1_ and _record2_ such that _record1_.[[ReferencingScriptOrModule]] is _record2_.[[ReferencingScriptOrModule]] and _record1_.[[Specifier]] is _record2_.[[Specifier]].</ins>
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            [[HostDefined]]
          </td>
          <td></td>
          <td></td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-resolveimportedmodule" type="abstract operation">
        <h1>
          <ins>
            ResolveImportedModule (
              _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
              _specifier_: a String,
            ): either a normal completion containing a Module Record or a throw completion
          </ins>
        </h1>
        <dl class="header"></dl>

        <emu-alg>
          1. Let _currentRealm_ be the current Realm.
          1. If there exists a Record _record_ in _currentRealm_.[[ModuleMap]] such that _record_.[[ReferencingScriptOrModule]] is _referencingScriptOrModule_ and _record_.[[Specifier]] is _specifier_, then
            1. Return NormalCompletion(_record_.[[ModuleRecord]]).
          1. Let _completion_ be Completion(HostResolveImportedModule(_referencingScriptOrModule_, _specifier_)).
          1. If _completion_ is a normal completion, then
            1. Add Record { [[ReferencingScriptOrModule]]: _referencingScriptOrModule_, [[Specifier]]: _specifier_, [[ModuleRecord]]: _completion_.[[Value]] } to _currentRealm_.[[ModuleMap]].
          1. Return _completion_.
        </emu-alg>

        <emu-note type="editor">
          Replace all the references to HostResolveImportedModule in the ecma262 speification with ResolveImportedModule.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-hostresolveimportedmodule" type="host-defined abstract operation">
        <h1>
          HostResolveImportedModule (
            _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
            _specifier_: a String,
          ): either a normal completion containing a Module Record or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <p>An implementation of HostResolveImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            If the returned Completion Record is a normal completion, it must be a normal completion containing an instance of a concrete subclass of Module Record.
          </li>
          <li>
            If a Module Record corresponding to the pair _referencingScriptOrModule_, _specifier_ does not exist or cannot be created, an exception must be thrown.
          </li>
          <li>
            <del>Each time this operation is called with a specific _referencingScriptOrModule_, _specifier_ pair as arguments it must return the same Module Record instance if it completes normally.</del>
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-importmoduledynamically" type="abstract operation">
        <h1>
          <ins>
            ImportModuleDynamically (
              _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
              _specifier_: a String,
              _promiseCapability_: a PromiseCapability Record,
            ): ~unused~
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It performs any necessary setup work in order to make available the module corresponding to _specifier_ occurring within the context of the script or module represented by _referencingScriptOrModule_. _referencingScriptOrModule_ may be *null* if there is no active script or module when the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression occurs. It then performs FinishDynamicImport to finish the dynamic import process.</dd>
        </dl>

        <emu-alg>
          1. Let _success_ be a new Abstract Closure that captures _referencingScriptOrModule_, _specifier_, and _promiseCapability_ and performs the following steps when called:
            1. Let _promise_ be ! PromiseResolve(%Promise%, *undefined*).
            1. Perform FinishDynamicImport(_referencingScriptOrModule_, _specifier_, _promiseCapability_, _promise_).
          1. Let _failure_ be a new Abstract Closure with parameters (_error_) that captures _referencingScriptOrModule_, _specifier_, and _promiseCapability_ and performs the following steps when called:
            1. Let _pc_ be ! NewPromiseCapability(%Promise%).
            1. Perform ! Call(_pc_.[[Reject]], *undefined*, &laquo; _error_ &raquo;).
            1. Perform FinishDynamicImport(_referencingScriptOrModule_, _specifier_, _promiseCapability_, _pc_.[[Promise]]).
          1. Let _currentRealm_ be the current Realm.
          1. If there exists a Record _record_ in _currentRealm_.[[ModuleMap]] such that _record_.[[ReferencingScriptOrModule]] is _referencingScriptOrModule_ and _record_.[[Specifier]] is _specifier_, then
            1. Perform _success_().
          1. Else,
            1. Perform HostImportModuleDynamically(_referencingScriptOrModule_, _specifier_, _success_, _failure_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-hostimportmoduledynamically" type="host-defined abstract operation">
        <h1>
          HostImportModuleDynamically (
            _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
            _specifier_: a String,
            <del>_promiseCapability_: a PromiseCapability Record,</del>
            <ins>_success_: an Abstract Closure,</ins>
            <ins>_failure_: an Abstract Closure,</ins>
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <p>An implementation of HostImportModuleDynamically must conform to the following requirements:</p>

        <ul>
          <li>
            It must return ~unused~. Success or failure must instead be signaled as discussed below.
          </li>
          <li>
            The host environment must conform to one of the two following sets of requirements:
            <dl>
              <dt>Success path</dt>

              <dd>
                <ul>
                  <li>At some future time, the host environment must perform <del>FinishDynamicImport(_referencingScriptOrModule_, _specifier_, _promiseCapability_, _promise_), where _promise_ is a Promise resolved with *undefined*</del><ins>_success_()</ins>.</li>

                  <li>Any subsequent call to HostResolveImportedModule after <del>FinishDynamicImport</del><ins>_success_</ins> has completed, given the arguments _referencingScriptOrModule_ and _specifier_, must return a normal completion containing a module which has already been evaluated, i.e. whose Evaluate concrete method has already been called and returned a normal completion.</li>
                </ul>
              </dd>

              <dt>Failure path</dt>

              <dd>
                <ul>
                  <li>At some future time, the host environment must perform <del>FinishDynamicImport(_referencingScriptOrModule_, _specifier_, _promiseCapability_, _promise_)</del><ins>_failure_(_error_)</ins>, where <del>_promise_</del><ins>_error_</ins> is <del>a Promise rejected with</del> an error representing the cause of failure.</li>
                </ul>
              </dd>
            </dl>
          </li>
          <li>
            <del>If the host environment takes the success path once for a given _referencingScriptOrModule_, _specifier_ pair, it must always do so for subsequent calls.</del>
          </li>
          <li>
            <del>The operation must not call _promiseCapability_.[[Resolve]] or _promiseCapability_.[[Reject]], but instead must treat _promiseCapability_ as an opaque identifying value to be passed through to FinishDynamicImport.</del>
          </li>
        </ul>

        <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to allow HostResolveImportedModule to synchronously retrieve the appropriate Module Record, and then calling its Evaluate concrete method. This might require performing similar normalization as HostResolveImportedModule does.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>