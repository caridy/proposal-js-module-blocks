<pre class="metadata">
title: JavaScript Module Blocks
stage: 2
contributors: Surma, Dan Ehrenberg
</pre>

<emu-clause id="sec-primary-expression">
  <h1>Primary Expression</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    PrimaryExpression[Yield, Await] :
      IdentifierReference[?Yield, ?Await]
      Literal
      ArrayLiteral[?Yield, ?Await]
      ObjectLiteral[?Yield, ?Await]
      FunctionExpression
      ClassExpression[?Yield, ?Await]
      GeneratorExpression
      AsyncFunctionExpression
      AsyncGeneratorExpression
      <ins>ModuleBlockExpression</ins>
      <ins>ModuleFunctionExpression</ins>
      <ins>ModuleGeneratorExpression</ins>
      <ins>ModuleAsyncFunctionExpression</ins>
      <ins>ModuleAsyncGeneratorExpression</ins>
      RegularExpressionLiteral
      TemplateLiteral[?Yield, ?Await, ~Tagged]
      CoverParenthesizedExpressionAndArrowParameterList[?Yield, ?Await] #parencover
  </emu-grammar>
</emu-clause>

<emu-clause id="sec-module-block-definitions">
  <h1>Module Block Definitions</h1>
  <h2>Syntax</h2>
  <emu-grammar type="definition">
    ModuleBlockExpression :
      `module` [no LineTerminator here] `{` ModuleBody? `}`
    ModuleFunctionExpression :
      `module` [no LineTerminator here] FunctionExpression
    ModuleGeneratorExpression :
      `module` [no LineTerminator here] GeneratorExpression
    ModuleAsyncFunctionExpression :
      `module` [no LineTerminator here] AsyncFunctionExpression
    ModuleAsyncGeneratorExpression :
      `module` [no LineTerminator here] AsyncGeneratorExpression
  </emu-grammar>

  <h2>Runtime Semantics: Evaluation</h2>
  <emu-grammar>PrimaryExpression : ModuleBlockExpression</emu-grammar>
  <emu-alg>
    1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%,  &laquo; [[HostDefined]], [[ModuleBlockBody]], [[SourceText]] &raquo;).
    1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleBlockExpression|.
    1. Let _parsedBody_ be ? ParseText(_body_, Module).
    1. Set _moduleBlock_.[[ModuleBlockBody]] to _parsedBody_.
    1. Perform ! HostInitializeModuleBlock(_moduleBlock_).
    1. Return _moduleBlock_.
  </emu-alg>

  <emu-grammar>PrimaryExpression : ModuleFunctionExpression</emu-grammar>
  <emu-alg>
    1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%,  &laquo; [[HostDefined]], [[ModuleBlockBody]], [[SourceText]] &raquo;).
    1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleFunctionExpression|.
    1. let _moduleFunctionSource_ be the source text matched by |FunctionExpression|.
    1. Let _parsedBody_ be ? ParseText("export default " + _moduleFunctionSource_, Module).
    1. Set _moduleBlock_.[[ModuleBlockBody]] to _parsedBody_.
    1. Perform ! HostInitializeModuleBlock(_moduleBlock_).
    1. Return _moduleBlock_.
  </emu-alg>

  <emu-grammar>PrimaryExpression : ModuleGeneratorExpression</emu-grammar>
  <emu-alg>
    1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%,  &laquo; [[HostDefined]], [[ModuleBlockBody]], [[SourceText]] &raquo;).
    1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleGeneratorExpression|.
    1. let _moduleFunctionSource_ be the source text matched by |GeneratorExpression|.
    1. Let _parsedBody_ be ? ParseText("export default " + _moduleFunctionSource_, Module).
    1. Set _moduleBlock_.[[ModuleBlockBody]] to _parsedBody_.
    1. Perform ! HostInitializeModuleBlock(_moduleBlock_).
    1. Return _moduleBlock_.
  </emu-alg>

  <emu-grammar>PrimaryExpression : ModuleAsyncFunctionExpression</emu-grammar>
  <emu-alg>
    1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%,  &laquo; [[HostDefined]], [[ModuleBlockBody]], [[SourceText]] &raquo;).
    1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleAsyncFunctionExpression|.
    1. let _moduleFunctionSource_ be the source text matched by |AsyncFunctionExpression|.
    1. Let _parsedBody_ be ? ParseText("export default " + _moduleFunctionSource_, Module).
    1. Set _moduleBlock_.[[ModuleBlockBody]] to _parsedBody_.
    1. Perform ! HostInitializeModuleBlock(_moduleBlock_).
    1. Return _moduleBlock_.
  </emu-alg>
  
  <emu-grammar>PrimaryExpression : ModuleAsyncGeneratorExpression</emu-grammar>
  <emu-alg>
    1. Let _moduleBlock_ be OrdinaryObjectCreate(%ModuleBlock.prototype%,  &laquo; [[HostDefined]], [[ModuleBlockBody]], [[SourceText]] &raquo;).
    1. Set _moduleBlock_.[[SourceText]] to the source text matched by |ModuleAsyncGeneratorExpression|.
    1. let _moduleFunctionSource_ be the source text matched by |AsyncGeneratorExpression|.
    1. Let _parsedBody_ be ? ParseText("export default " + _moduleFunctionSource_, Module).
    1. Set _moduleBlock_.[[ModuleBlockBody]] to _parsedBody_.
    1. Perform ! HostInitializeModuleBlock(_moduleBlock_).
    1. Return _moduleBlock_.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-moduleblock">
  <h1>ModuleBlock ( _body_ )</h1>
  <emu-alg>
    1. Throw a *TypeError* exception.
  </emu-alg>
</emu-clause>

<emu-clause id="sec-moduleblock.prototype">
  <h1>ModuleBlock.prototype</h1>
  <p>The initial value of `ModuleBlock.prototype` is the ModuleBlock prototype object.</p>
  <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
</emu-clause>

<emu-clause id="sec-properties-of-the-moduleblock-prototype-object">
  <h1>Properties of the ModuleBlock Prototype Object</h1>
  <p>The <dfn>ModuleBlock prototype object</dfn>:</p>
  <ul>
    <li>is <dfn>%ModuleBlock.prototype%</dfn>.</li>
    <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.</li>
    <li>is an ordinary object.</li>
  </ul>

  <emu-clause id="sec-moduleblock.prototype.tostring">
    <h1>ModuleBlock.prototype.toString ( )</h1>
    <p>The following steps are taken:</p>
    <emu-alg>
      1. Let _module_ be the *this* value.
      1. If Type(_module_) is Object and has the internal slot [[ModuleBlockBody]]
        1. Return _module_.[[SourceText]].
      1. Throw a *TypeError* exception.
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-import-calls">
  <h1>Import Calls</h1>

  <emu-clause id="sec-import-call-runtime-semantics-evaluation">
    <h1>Runtime Semantics: Evaluation</h1>

    <emu-grammar>ImportCall : `import` `(` AssignmentExpression `)`</emu-grammar>
    <emu-alg>
      1. Let _referencingScriptOrModule_ be ! GetActiveScriptOrModule().
      1. Let _argRef_ be the result of evaluating |AssignmentExpression|.
      1. Let _specifier_ be ? GetValue(_argRef_).
      1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
      1. <del>Let _specifierString_ be ToString(_specifier_).</del>
      1. <ins>If Type(_specifier_) is not Object or _specifier_ does not have the internal slot [[ModuleBlockBody]]</ins>
        1. <ins>Set _specifier_ to ToString(_specifier_).</ins>
        1. IfAbruptRejectPromise(<del>_specifierString_</del><ins>_specifier_</ins>, _promiseCapability_).
      1. Perform ! HostImportModuleDynamically(_referencingScriptOrModule_, <del>_specifierString_</del><ins>_specifier_</ins>, _promiseCapability_).
      1. Return _promiseCapability_.[[Promise]].
    </emu-alg>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-hostinitializemoduleblock" type="host-defined abstract operation">
  <h1>
    HostInitializeModuleBlock (
      _moduleBlock_: a Module Block,
    )
  </h1>
  <dl class="header">
    <dt>description</dt>
    <dd>Initializes a Module Block with host-dependent information.</dd>
  </dl>
</emu-clause>


<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>Executable Code and Execution Contexts</h1>

  <emu-clause id="sec-code-realms">
    <h1>Realms</h1>
    <p>Before it is evaluated, all ECMAScript code must be associated with a <dfn id="realm" variants="realms">realm</dfn>. Conceptually, a realm consists of a set of intrinsic objects, an ECMAScript global environment, all of the ECMAScript code that is loaded within the scope of that global environment, and other associated state and resources.</p>
    <p>A realm is represented in this specification as a <dfn id="realm-record" variants="Realm Records">Realm Record</dfn> with the fields specified in <emu-xref href="#table-realm-record-fields"></emu-xref>:</p>
    <emu-table id="table-realm-record-fields" caption="Realm Record Fields" oldids="table-21">
      <table>
        <tr>
          <th>
            Field Name
          </th>
          <th>
            Value
          </th>
          <th>
            Meaning
          </th>
        </tr>
        <tr>
          <td>
            [[Intrinsics]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            [[GlobalObject]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            [[GlobalEnv]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            [[TemplateMap]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            <ins>[[ModuleMap]]</ins>
          </td>
          <td>
            <ins>a List of Record { [[ReferencingScriptOrModule]]: Script Record or Module Record or *null*, [[Specifier]]: String, [[ModuleRecord]]: Module Record }</ins>
          </td>
          <td>
            <p><ins>Module Records are cached separately per Realm: two imports from the same realm using the same specifier from the same referencing script or module must resolve to the same Module Record. The cache needs to be per-Realm to support cases when [[ReferencingScriptOrModule]] is *null*.</ins></p>
            <p><ins>This List respects the following invariant:</ins></p>
            <ul>
              <li>
                <ins>It does not contain two Records _record1_ and _record2_ such that _record1_.[[ReferencingScriptOrModule]] is _record2_.[[ReferencingScriptOrModule]] and _record1_.[[Specifier]] is _record2_.[[Specifier]].</ins>
              </li>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            [[HostDefined]]
          </td>
          <td></td>
          <td></td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-resolveimportedmodule" type="abstract operation">
        <h1>
          <ins>
            ResolveImportedModule (
              _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
              _specifier_: a String,
            ): either a normal completion containing a Module Record or a throw completion
          </ins>
        </h1>
        <dl class="header"></dl>

        <emu-alg>
          1. Let _currentRealm_ be the current Realm.
          1. If there exists a Record _record_ in _currentRealm_.[[ModuleMap]] such that _record_.[[ReferencingScriptOrModule]] is _referencingScriptOrModule_ and _record_.[[Specifier]] is _specifier_, then
            1. Return NormalCompletion(_record_.[[ModuleRecord]]).
          1. Let _completion_ be Completion(HostResolveImportedModule(_referencingScriptOrModule_, _specifier_)).
          1. If _completion_ is a normal completion, then
            1. Add Record { [[ReferencingScriptOrModule]]: _referencingScriptOrModule_, [[Specifier]]: _specifier_, [[ModuleRecord]]: _completion_.[[Value]] } to _currentRealm_.[[ModuleMap]].
          1. Return _completion_.
        </emu-alg>

        <emu-note type="editor">
          Replace all the references to HostResolveImportedModule in the ecma262 speification with ResolveImportedModule.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-hostresolveimportedmodule" type="host-defined abstract operation">
        <h1>
          HostResolveImportedModule (
            _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
            _specifier_: a String,
          ): either a normal completion containing a Module Record or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <p>An implementation of HostResolveImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            If the returned Completion Record is a normal completion, it must be a normal completion containing an instance of a concrete subclass of Module Record.
          </li>
          <li>
            If a Module Record corresponding to the pair _referencingScriptOrModule_, _specifier_ does not exist or cannot be created, an exception must be thrown.
          </li>
          <li>
            <del>Each time this operation is called with a specific _referencingScriptOrModule_, _specifier_ pair as arguments it must return the same Module Record instance if it completes normally.</del>
          </li>
        </ul>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>